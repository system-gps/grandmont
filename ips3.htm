<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹å‹¢æ§åˆ¶ 3D ç²’å­ç‰¹æ•ˆ</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Inter', 'Microsoft JhengHei', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; cursor: crosshair; }
        #video-feed { position: absolute; bottom: 20px; right: 20px; width: 240px; height: 180px; transform: scaleX(-1); border-radius: 12px; border: 2px solid rgba(255,255,255,0.2); z-index: 10; opacity: 0.8; }
        
        /* Glassmorphism UI */
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        .slider-thumb::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #ffffff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Custom Scrollbar for shape list */
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05); 
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2); 
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Hidden Video Element for MediaPipe -->
    <video id="input-video" style="display:none"></video>
    <!-- Visible Preview (Canvas for drawing landmarks) -->
    <canvas id="video-feed"></canvas>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 w-full h-full pointer-events-none z-20 flex flex-col justify-between p-6">
        
        <!-- Header -->
        <div class="pointer-events-auto flex justify-between items-start">
            <div class="glass-panel p-4 rounded-xl text-white max-w-xs">
                <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">ä»¥å¤ªç²’å­ç‰¹æ•ˆ</h1>
                <p class="text-xs text-gray-400 mt-1">
                    <span id="status-text" class="text-yellow-400">ç­‰å¾…ç›¸æ©Ÿå•Ÿå‹•...</span>
                </p>
                <div class="mt-2 text-xs text-gray-300 space-y-1">
                    <p>ğŸ–±ï¸ <b>æ»‘é¼ /æ‰‹å‹¢ï¼š</b> äº’å‹•æ§åˆ¶</p>
                    <p>ğŸ’¥ <b>å¤§çˆ†ç‚¸/ç…™ç«ï¼š</b> æŒ‰ä½èšæ°£ / æ”¾é–‹çˆ†ç™¼</p>
                    <p>ğŸŒ€ <b>æ¼©æ¸¦æ¨¡å¼ï¼š</b> æŒ‰ä½å•Ÿå‹•è¶…é »åŠ é€Ÿ</p>
                </div>
            </div>
            
            <button id="camera-toggle" class="pointer-events-auto glass-panel px-4 py-2 rounded-lg text-white text-sm font-medium hover:bg-white/10 transition flex items-center gap-2">
                <span id="cam-icon">ğŸ“¹</span> å•Ÿå‹•ç›¸æ©Ÿ
            </button>
        </div>

        <!-- Controls Bottom Left -->
        <div class="pointer-events-auto glass-panel p-4 rounded-xl text-white w-64 space-y-4 mb-4">
            
            <!-- Shape Selector -->
            <div>
                <label class="text-xs font-semibold text-gray-400 uppercase tracking-wider">å½¢ç‹€æ¨¡æ¿</label>
                <div class="grid grid-cols-2 gap-2 mt-2 max-h-48 overflow-y-auto custom-scrollbar pr-1">
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition active-shape ring-1 ring-white/50" data-shape="heart">â¤ï¸ æ„›å¿ƒ</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="saturn">ğŸª åœŸæ˜Ÿ</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="flower">ğŸŒ¸ èŠ±æœµ</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="spiral">ğŸŒ€ éŠ€æ²³</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="dna">ğŸ§¬ èºæ—‹</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="buddha">ğŸ§˜ æ›¼é™€ç¾…</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="blackhole">ğŸ•³ï¸ é»‘æ´</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition" data-shape="tornado">ğŸŒªï¸ é¾æ²é¢¨</button>
                    
                    <!-- NEW TEMPLATES -->
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition bg-purple-500/20" data-shape="vortex">âš¡ èƒ½é‡æ¼©æ¸¦</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition bg-orange-500/20" data-shape="fireworks">ğŸ† ç…™ç«ç‰¹æ•ˆ</button>
                    
                    <!-- Special Shapes -->
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition bg-red-500/20" data-shape="bigbang">ğŸ’¥ çœŸãƒ»å¤§çˆ†ç‚¸</button>
                    <button class="shape-btn bg-white/10 hover:bg-white/20 py-2 rounded text-xs transition bg-yellow-500/20" data-shape="grandmont">âœ¨ GRANDMONT</button>
                </div>
            </div>

            <!-- Color Picker -->
            <div>
                <label class="text-xs font-semibold text-gray-400 uppercase tracking-wider block mb-2">ç²’å­é¡è‰²</label>
                <div class="flex items-center gap-3">
                    <input type="color" id="color-picker" value="#00ffff" class="w-8 h-8 rounded cursor-pointer border-0 p-0 bg-transparent">
                    <span class="text-xs text-gray-300">å·²é¸é¡è‰²</span>
                </div>
            </div>
            
            <!-- Particle Count -->
            <div>
                <label class="text-xs font-semibold text-gray-400 uppercase tracking-wider flex justify-between">
                    ç²’å­æ•¸é‡ (æ•ˆèƒ½) <span id="density-val">15k</span>
                </label>
                <input type="range" id="density-slider" min="1000" max="30000" step="1000" value="15000" class="w-full mt-2 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer slider-thumb">
            </div>

        </div>
    </div>

    <script>
    // Ensure scripts are loaded before running
    window.addEventListener('load', function() {
        if (typeof THREE === 'undefined') {
            document.getElementById('status-text').innerText = "éŒ¯èª¤: ç„¡æ³•è¼‰å…¥ 3D å¼•æ“ï¼Œè«‹é‡æ–°æ•´ç†ã€‚";
            document.getElementById('status-text').className = "text-red-500";
            return;
        }

        // --- 1. Three.js Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // --- 2. Particle System Logic ---
        let particles;
        let positions;
        let basePositions; 
        let velocities; // Added for Fireworks
        let colors; 
        let geometry;
        let material;
        let particleCount = 15000; 
        let currentShape = 'heart';
        let mainColor = new THREE.Color(0x00ffff);
        
        // Big Bang Animation State
        let bigbangFactor = 0; // 0 = Exploded/Idle, 1 = Gathered

        // Text Generation Helper
        function getTextCoordinates(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 3000; canvas.height = 800; // Increased height to fit bottom of letters
            // Use bold and thick font for better particles
            ctx.font = '900 320px "Arial Black", Arial, sans-serif'; // Slightly smaller font to ensure fit
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            
            const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
            const coords = [];
            const step = 4; // Sampling step
            
            for(let y=0; y<canvas.height; y+=step) {
                for(let x=0; x<canvas.width; x+=step) {
                    // Check alpha
                    if(data[(y*canvas.width+x)*4+3] > 128) {
                        coords.push({
                            // Center and scale down slightly reduced to ensure full width visibility
                            x: (x - canvas.width/2) * 0.018,
                            y: -(y - canvas.height/2) * 0.018
                        });
                    }
                }
            }
            
            // Fisher-Yates Shuffle
            // This is crucial! It randomizes the order of coordinates.
            // If we don't do this, particles fill from top-left to bottom-right.
            // If particleCount < coords.length, the bottom of the text gets cut off.
            // Shuffling ensures particles are distributed evenly across the whole text shape.
            for (let i = coords.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [coords[i], coords[j]] = [coords[j], coords[i]];
            }
            
            return coords;
        }

        const getTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        };

        const initParticles = () => {
            if (particles) scene.remove(particles);

            positions = new Float32Array(particleCount * 3);
            basePositions = new Float32Array(particleCount * 3); 
            velocities = new Float32Array(particleCount * 3); // Physics velocity
            colors = new Float32Array(particleCount * 3);
            
            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Enable Vertex Colors
            material = new THREE.PointsMaterial({
                size: 0.5,
                map: getTexture(),
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true,
                vertexColors: true 
            });

            // Initialize all colors to mainColor
            for (let i = 0; i < particleCount; i++) {
                colors[i*3] = mainColor.r;
                colors[i*3+1] = mainColor.g;
                colors[i*3+2] = mainColor.b;
            }

            generateShape(currentShape);
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        };

        const generateShape = (shape) => {
            if (!shape) shape = 'heart'; 
            if (!geometry) return; 

            // Reset Big Bang state
            if (shape !== 'bigbang') bigbangFactor = 0;

            // Prepare text coords if needed
            let textCoords = [];
            if (shape === 'grandmont') {
                textCoords = getTextCoordinates('GRANDMONT');
                // Auto-set color to Gold for Grandmont
                mainColor.setHex(0xFFD700); 
                document.getElementById('color-picker').value = "#FFD700";
            }

            // Reset Colors
            const cols = geometry.attributes.color.array;
            for (let i = 0; i < particleCount; i++) {
                cols[i*3] = mainColor.r;
                cols[i*3+1] = mainColor.g;
                cols[i*3+2] = mainColor.b;
            }
            geometry.attributes.color.needsUpdate = true;

            const arr = basePositions;
            const vels = velocities;

            for (let i = 0; i < particleCount; i++) {
                let x = 0, y = 0, z = 0;
                const i3 = i * 3;

                // --- SHAPES ---
                if (shape === 'grandmont') {
                    // Map particles to text
                    if (textCoords.length > 0) {
                        const coord = textCoords[i % textCoords.length];
                        x = coord.x + (Math.random() - 0.5) * 0.1;
                        y = coord.y + (Math.random() - 0.5) * 0.1;
                        z = (Math.random() - 0.5) * 0.5; // Slight depth
                    } else {
                        x = 0; y = 0; z = 0;
                    }

                } else if (shape === 'vortex') {
                    // NEW: Energy Vortex
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 5 + Math.random() * 20; // Wide top
                    const height = (Math.random() - 0.5) * 40;
                    
                    x = radius * Math.cos(angle);
                    z = radius * Math.sin(angle);
                    y = height;

                } else if (shape === 'fireworks') {
                    // NEW: Fireworks (Start at center)
                    x = (Math.random() - 0.5) * 2;
                    y = (Math.random() - 0.5) * 2;
                    z = (Math.random() - 0.5) * 2;

                    // Initialize Explosion Velocities
                    // Random spherical vector
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const speed = 0.5 + Math.random() * 1.5; // varied speed

                    vels[i3] = speed * Math.sin(phi) * Math.cos(theta);
                    vels[i3+1] = speed * Math.sin(phi) * Math.sin(theta);
                    vels[i3+2] = speed * Math.cos(phi);

                } else if (shape === 'bigbang') {
                    const r = 40 + Math.pow(Math.random(), 2) * 100; 
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } else if (shape === 'heart') {
                    const t = Math.random() * Math.PI * 2;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random() - 0.5) * 10;
                    x *= 0.5; y *= 0.5;
                } else if (shape === 'saturn') {
                    if (i < particleCount * 0.4) {
                        const phi = Math.acos(-1 + (2 * i) / (particleCount * 0.4));
                        const theta = Math.sqrt((particleCount * 0.4) * Math.PI) * phi;
                        const r = 6;
                        x = r * Math.cos(theta) * Math.sin(phi);
                        y = r * Math.sin(theta) * Math.sin(phi);
                        z = r * Math.cos(phi);
                    } else {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 9 + Math.random() * 5;
                        x = Math.cos(angle) * dist;
                        y = (Math.random() - 0.5) * 0.5;
                        z = Math.sin(angle) * dist;
                        const tilt = 0.4;
                        const yTemp = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const zTemp = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = yTemp; z = zTemp;
                    }
                } else if (shape === 'flower') {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = 10 * Math.cos(2 * theta) + 2; 
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = (Math.random() - 0.5) * 5;
                } else if (shape === 'spiral') {
                    const angle = i * 0.01;
                    const r = i * 0.002;
                    const arms = 3;
                    const spin = angle * arms;
                    x = r * Math.cos(spin) * 10;
                    y = (Math.random() - 0.5) * (10 - r*2);
                    z = r * Math.sin(spin) * 10;
                } else if (shape === 'dna') {
                    const t = (i / particleCount) * Math.PI * 10;
                    const r = 5;
                    const strand = i % 2 === 0 ? 1 : -1;
                    x = r * Math.cos(t + (strand * Math.PI));
                    y = (i / particleCount) * 40 - 20;
                    z = r * Math.sin(t + (strand * Math.PI));
                    x += (Math.random() - 0.5);
                    z += (Math.random() - 0.5);
                } else if (shape === 'buddha') {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI;
                    const r = 8;
                    const p = 2, q = 3;
                    const rad = r * (2 + Math.cos(q * u));
                    x = rad * Math.cos(p * u);
                    y = rad * Math.sin(p * u);
                    z = r * Math.sin(q * u);
                    if (Math.random() > 0.8) {
                         const theta = Math.random() * Math.PI * 2;
                         const phi = Math.acos(2 * Math.random() - 1);
                         x = 15 * Math.sin(phi) * Math.cos(theta);
                         y = 15 * Math.sin(phi) * Math.sin(theta);
                         z = 15 * Math.cos(phi);
                    }
                } else if (shape === 'blackhole') {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 5 + Math.random() * Math.random() * 20; 
                    const height = (50 / (dist + 0.1)) * (Math.random() - 0.5) * 0.5;
                    x = Math.cos(angle) * dist;
                    z = Math.sin(angle) * dist;
                    y = height;
                    if (i > particleCount * 0.9) {
                        const rJet = Math.random() * 2;
                        const hJet = (Math.random() * 40) - 20;
                        x = Math.cos(angle) * rJet * (Math.abs(hJet)*0.1);
                        z = Math.sin(angle) * rJet * (Math.abs(hJet)*0.1);
                        y = hJet;
                    }
                } else if (shape === 'tornado') {
                    const h = (i / particleCount) * 40 - 20;
                    const r = 2 + Math.abs(h) * 0.5 + Math.random() * 2;
                    const angle = h * 2 + Math.random();
                    x = r * Math.cos(angle);
                    z = r * Math.sin(angle);
                    y = h;
                } 

                basePositions[i3] = x;
                basePositions[i3 + 1] = y;
                basePositions[i3 + 2] = z;

                // Reset actual positions
                positions[i3] = 0;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = 0;
            }
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
        };

        const state = {
            targetScale: 1,
            currentScale: 1,
            handDistance: 0,
            handsDetected: false,
            tension: 0, 
            rotationY: 0,
            targetX: 0, 
            targetY: 0 
        };

        // --- Mouse Events ---
        container.addEventListener('mousemove', (e) => {
            if (!state.handsDetected) {
                const mouseX = (e.clientX / window.innerWidth) * 2 - 1; 
                const mouseY = -(e.clientY / window.innerHeight) * 2 + 1; 
                state.targetX = mouseX * 25;
                state.targetY = mouseY * 15;
            }
        });
        container.addEventListener('mousedown', () => { if (!state.handsDetected) state.tension = 1; });
        container.addEventListener('mouseup', () => { if (!state.handsDetected) state.tension = 0; });
        container.addEventListener('wheel', (e) => {
            const zoomSpeed = 0.05;
            camera.position.z += e.deltaY * zoomSpeed;
            camera.position.z = Math.max(10, Math.min(100, camera.position.z));
        });
        container.addEventListener('touchstart', () => { if(!state.handsDetected) state.tension = 1; });
        container.addEventListener('touchend', () => { if(!state.handsDetected) state.tension = 0; });

        // --- Animation ---
        const clock = new THREE.Clock();
        const goldenAngle = Math.PI * (3 - Math.sqrt(5));

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // Slower Scale smoothing
            state.currentScale += (state.targetScale - state.currentScale) * 2.0 * delta;
            
            // Slower Position Follow (was 0.1) -> 0.03 for lazy float feel
            particles.position.x += (state.targetX - particles.position.x) * 0.03;
            particles.position.y += (state.targetY - particles.position.y) * 0.03;

            const pos = geometry.attributes.position.array;
            const cols = geometry.attributes.color.array;
            const base = basePositions;
            const vels = velocities; // Physics velocity

            let autoSpin = 0.002;
            let tensionSpin = state.tension * 0.2; 
            
            // Big Bang Logic Check
            if (currentShape === 'bigbang') {
                autoSpin = 0; 
                tensionSpin = 0;
                if (state.tension > 0.5) bigbangFactor += (1 - bigbangFactor) * 0.05; 
                else bigbangFactor += (0 - bigbangFactor) * 0.02;
            }

            particles.rotation.y += autoSpin + tensionSpin;
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                let tx, ty, tz;

                if (currentShape === 'grandmont') {
                    // GRANDMONT EFFECT
                    tx = base[i3] * state.currentScale;
                    ty = base[i3+1] * state.currentScale;
                    tz = base[i3+2] * state.currentScale;

                    // 1. Fluid Wave
                    // Vertical ripple based on X position and time
                    const wave = Math.sin(tx * 0.2 + time * 3) * 0.5;
                    ty += wave;

                    // 2. Holographic Scan
                    // A bar of light moving across the text
                    const scanX = (time * 15) % 80 - 40; // Moves from -40 to 40
                    const distToScan = Math.abs(tx - scanX);
                    
                    // If particle is close to the scan line
                    if (distToScan < 3) {
                        // Lift it up (Z axis pop)
                        tz += (3 - distToScan) * 2;
                        // Brighten color to White/Blue ish
                        cols[i3] = 0.8; cols[i3+1] = 0.9; cols[i3+2] = 1.0;
                    } else {
                        // Return to Gold
                        cols[i3] = 1.0; cols[i3+1] = 0.84; cols[i3+2] = 0.0;
                    }

                } else if (currentShape === 'vortex') {
                    // NEW: Vortex Dynamic Logic
                    let px = base[i3];
                    let py = base[i3+1];
                    let pz = base[i3+2];

                    let r = Math.sqrt(px*px + pz*pz);
                    let angle = Math.atan2(pz, px);
                    
                    // Base speed
                    let speed = 0.05 + (10 / (r + 1)) * 0.01; 
                    
                    // Interaction: Tension Effect
                    if (state.tension > 0.1) {
                        speed += state.tension * 0.5; // Much faster
                    }
                    angle += speed + (time * 0.5); 

                    // Faster flow on tension
                    let flowSpeed = 5 + (state.tension * 20); 
                    let flowY = py - (time * flowSpeed); 
                    flowY = ((flowY + 20) % 40 + 40) % 40 - 20;

                    // Squeeze and Tunnel Effect
                    const squeeze = 1 - (state.tension * 0.7); 
                    
                    let funnel = 1 + (flowY + 20) / 40; 
                    if (state.tension > 0.1) {
                        funnel = 1 + ((flowY + 20) / 40) * (1 - state.tension); 
                    }

                    let currentR = r * squeeze * funnel;

                    // Add Jitter
                    let jitterX = 0, jitterY = 0, jitterZ = 0;
                    if (state.tension > 0.2) {
                        const jStr = state.tension * 0.5;
                        jitterX = (Math.random() - 0.5) * jStr;
                        jitterY = (Math.random() - 0.5) * jStr;
                        jitterZ = (Math.random() - 0.5) * jStr;
                    }
                    
                    tx = currentR * Math.cos(angle) * state.currentScale + jitterX;
                    ty = flowY * state.currentScale + jitterY;
                    tz = currentR * Math.sin(angle) * state.currentScale + jitterZ;

                    // Color: Brighten core
                    if (state.tension > 0.3 && currentR < 5) {
                         cols[i3] = 1; cols[i3+1] = 1; cols[i3+2] = 1;
                    } else {
                         cols[i3] = mainColor.r; cols[i3+1] = mainColor.g; cols[i3+2] = mainColor.b;
                    }

                } else if (currentShape === 'fireworks') {
                    // NEW: Fireworks Physics Logic
                    
                    if (state.tension > 0.1) {
                        tx = 0; ty = 0; tz = 0;
                        tx += (Math.random()-0.5) * 2;
                        ty += (Math.random()-0.5) * 2;
                        tz += (Math.random()-0.5) * 2;
                        base[i3] = 0; base[i3+1] = 0; base[i3+2] = 0;
                    } else {
                        base[i3] += vels[i3];
                        base[i3+1] += vels[i3+1];
                        base[i3+2] += vels[i3+2];
                        vels[i3+1] -= 0.005; // Gravity
                        vels[i3] *= 0.98; vels[i3+1] *= 0.98; vels[i3+2] *= 0.98;

                        if (base[i3+1] < -30 || Math.abs(base[i3]) > 50) {
                            base[i3] = 0; base[i3+1] = 0; base[i3+2] = 0;
                            const speed = 0.5 + Math.random() * 1.5;
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            vels[i3] = speed * Math.sin(phi) * Math.cos(theta);
                            vels[i3+1] = speed * Math.sin(phi) * Math.sin(theta);
                            vels[i3+2] = speed * Math.cos(phi);
                        }
                        tx = base[i3]; ty = base[i3+1]; tz = base[i3+2];
                    }
                    cols[i3] = mainColor.r; cols[i3+1] = mainColor.g; cols[i3+2] = mainColor.b;

                } else if (currentShape === 'bigbang') {
                    // Big Bang Logic
                    const y = 1 - (i / (particleCount - 1)) * 2; 
                    const radius = Math.sqrt(1 - y * y);
                    const theta = goldenAngle * i;
                    
                    const r = 12; 
                    const gx = Math.cos(theta) * radius * r;
                    const gy = y * r;
                    const gz = Math.sin(theta) * radius * r;
                    
                    const driftAmp = (1 - bigbangFactor) * 15; 
                    const bx = base[i3] + Math.cos(time * 0.2 + i * 0.1) * driftAmp;
                    const by = base[i3+1] + Math.sin(time * 0.3 + i * 0.2) * driftAmp;
                    const bz = base[i3+2] + Math.sin(time * 0.1 + i * 0.1) * driftAmp;

                    tx = bx * (1 - bigbangFactor) + gx * bigbangFactor;
                    ty = by * (1 - bigbangFactor) + gy * bigbangFactor;
                    tz = bz * (1 - bigbangFactor) + gz * bigbangFactor;

                    const vibrationStrength = Math.pow(bigbangFactor, 4) * 5.0; 
                    if (vibrationStrength > 0.1) {
                        tx += (Math.random()-0.5) * vibrationStrength;
                        ty += (Math.random()-0.5) * vibrationStrength;
                        tz += (Math.random()-0.5) * vibrationStrength;
                    }

                    const distFromCenter = Math.sqrt(gx*gx + gy*gy + gz*gz);
                    if (bigbangFactor > 0.7 && distFromCenter > 10) {
                         cols[i3] = 1; cols[i3+1] = 1; cols[i3+2] = 0.8;
                    } else {
                         cols[i3] = mainColor.r; cols[i3+1] = mainColor.g; cols[i3+2] = mainColor.b;
                    }

                } else {
                    // Standard Shapes
                    cols[i3] = mainColor.r; cols[i3+1] = mainColor.g; cols[i3+2] = mainColor.b;
                    tx = base[i3] * state.currentScale;
                    ty = base[i3+1] * state.currentScale;
                    tz = base[i3+2] * state.currentScale;
                    if (state.tension > 0.1) {
                        const jitter = state.tension * 2.0; 
                        tx += (Math.random() - 0.5) * jitter;
                        ty += (Math.random() - 0.5) * jitter;
                        tz += (Math.random() - 0.5) * jitter;
                    }
                    if (currentShape === 'blackhole') {
                        const angle = Math.atan2(tz, tx);
                        const dist = Math.sqrt(tx*tx + tz*tz);
                        tx += Math.cos(angle + Math.PI/2) * (10/dist) * 0.1;
                        tz += Math.sin(angle + Math.PI/2) * (10/dist) * 0.1;
                    } else if (currentShape === 'vortex') {
                        ty += Math.sin(time * 10 + i) * 0.5;
                    } else {
                        tx += Math.sin(time + i) * 0.05;
                        ty += Math.cos(time + i * 0.5) * 0.05;
                    }
                }

                let lerpSpeed = 0.1;
                if (currentShape === 'bigbang') lerpSpeed = 0.1;
                else if (currentShape === 'fireworks') lerpSpeed = 0.5; 
                else if (currentShape === 'vortex') lerpSpeed = 0.5;
                else if (currentShape === 'grandmont') lerpSpeed = 0.2;

                pos[i3] += (tx - pos[i3]) * lerpSpeed;
                pos[i3+1] += (ty - pos[i3+1]) * lerpSpeed;
                pos[i3+2] += (tz - pos[i3+2]) * lerpSpeed;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- MediaPipe Logic (Same as before) ---
        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('video-feed');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('status-text');

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                state.handsDetected = true;
                statusText.innerText = "åµæ¸¬åˆ°æ‰‹éƒ¨ - æ§åˆ¶ä¸­";
                statusText.className = "text-green-400";
                for (const landmarks of results.multiHandLandmarks) {
                    drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});
                }
                let centerX = 0, centerY = 0;
                if (results.multiHandLandmarks.length === 2) {
                    const hand1 = results.multiHandLandmarks[0];
                    const hand2 = results.multiHandLandmarks[1];
                    centerX = (hand1[0].x + hand2[0].x) / 2;
                    centerY = (hand1[0].y + hand2[0].y) / 2;
                    const dist = Math.sqrt(Math.pow(hand1[0].x - hand2[0].x, 2) + Math.pow(hand1[0].y - hand2[0].y, 2));
                    const clampedDist = Math.max(0.1, Math.min(dist, 0.8));
                    state.targetScale = 0.5 + ((clampedDist - 0.1) / 0.7 * 2.5);
                    const getHandOpenness = (lm) => {
                        const wrist = lm[0]; const tip = lm[12];
                        return Math.sqrt(Math.pow(wrist.x - tip.x, 2) + Math.pow(wrist.y - tip.y, 2));
                    };
                    const open1 = getHandOpenness(hand1);
                    const open2 = getHandOpenness(hand2);
                    const avgOpen = (open1 + open2) / 2;
                    state.tension = 1 - ((Math.max(0.1, Math.min(avgOpen, 0.35)) - 0.1) / 0.25); 
                } else {
                    const hand1 = results.multiHandLandmarks[0];
                    centerX = hand1[0].x;
                    centerY = hand1[0].y;
                    const wrist = hand1[0];
                    const tip = hand1[12];
                    const open = Math.sqrt(Math.pow(wrist.x - tip.x, 2) + Math.pow(wrist.y - tip.y, 2));
                    state.tension = 1 - ((Math.max(0.1, Math.min(open, 0.35)) - 0.1) / 0.25);
                }
                state.targetX = (1 - centerX - 0.5) * 60; 
                state.targetY = -(centerY - 0.5) * 40;
            } else {
                state.handsDetected = false;
                statusText.innerText = "æœªåµæ¸¬åˆ°æ‰‹éƒ¨ - æ»‘é¼ æ§åˆ¶ä¸­";
                statusText.className = "text-yellow-400";
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.shape-btn').forEach(b => {
                    b.classList.remove('ring-1', 'ring-white/50');
                });
                e.currentTarget.classList.add('ring-1', 'ring-white/50');
                currentShape = e.currentTarget.dataset.shape;
                generateShape(currentShape);
            });
        });

        // Particle Density Slider
        document.getElementById('density-slider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            particleCount = val;
            document.getElementById('density-val').innerText = (val/1000) + 'k';
            initParticles();
        });

        document.getElementById('color-picker').addEventListener('input', (e) => {
            mainColor.set(e.target.value);
        });

        // INITIALIZE SYSTEM
        initParticles();
        animate();
    });
    </script>
</body>
</html>