<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­å‰µä¸–ç´€ï¼šæ™ºæ…§æ³‰</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Microsoft JhengHei', 'Segoe UI', sans-serif;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #camera-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            z-index: 10;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0,0,0,0.5);
            display: none; 
            transform: scaleX(-1);
        }

        #video-feed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.6;
        }

        #output-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 21;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        #toggle-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 242, 96, 0.3);
        }

        #ui-panel {
            position: absolute;
            top: 70px;
            left: 20px;
            width: 280px; 
            background: rgba(10, 10, 10, 0.7);
            backdrop-filter: blur(16px);
            padding: 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: white;
            z-index: 20;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
        }

        #ui-panel.closed {
            transform: translateX(-150%) scale(0.9);
            opacity: 0;
            pointer-events: none;
        }

        h2 {
            margin: 0 0 20px 0;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(90deg, #00f260, #0575e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .control-group { margin-bottom: 20px; }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.75rem;
            color: #aaa;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .shape-grid {
            display: grid;
            grid-template-columns: 1fr; 
            gap: 10px;
        }

        button.shape-btn, button.action-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc;
            padding: 12px 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: flex-start; 
            text-align: left;
        }

        .btn-icon {
            font-size: 1.8rem; 
            margin-right: 15px;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.3));
        }

        button.shape-btn:hover, button.action-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border-color: rgba(255,255,255,0.4);
            transform: translateY(-2px);
        }

        button.shape-btn.active, button.action-btn.active {
            background: rgba(0, 242, 96, 0.15);
            border-color: #00f260;
            color: #fff;
            box-shadow: 0 0 20px rgba(0, 242, 96, 0.3);
        }

        button.action-btn.active {
            background: rgba(255, 50, 50, 0.2);
            border-color: #ff4444;
            color: #ff4444;
            box-shadow: 0 0 20px rgba(255, 68, 68, 0.2);
        }

        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: white;
            font-size: 0.85rem;
            outline: none;
            cursor: pointer;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            padding: 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #00f260;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0,242,96,0.5);
        }

        input[type="color"] {
            -webkit-appearance: none;
            border: none;
            width: 100%;
            height: 35px;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            padding: 0;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch {
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
        }

        #energy-bar-container {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.05);
            margin-top: 5px;
            border-radius: 3px;
            overflow: hidden;
            display: none;
        }
        #energy-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe, #fff);
            box-shadow: 0 0 10px #00f2fe;
            transition: width 0.05s linear;
        }

        #status {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 0.75rem;
            color: #666;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dot {
            width: 6px;
            height: 6px;
            background-color: #333;
            border-radius: 50%;
            transition: all 0.3s;
        }
        .dot.active {
            background-color: #00f260;
            box-shadow: 0 0 8px #00f260;
        }

        .gesture-alert {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            z-index: 50;
            text-align: center;
            white-space: nowrap;
        }

        #love-detected-msg { color: #ff69b4; text-shadow: 0 0 20px #ff1493; }
        #saturn-detected-msg { color: #ffd700; text-shadow: 0 0 20px #ffaa00; }
        #wisdom-detected-msg { color: #00ffff; text-shadow: 0 0 20px #0088ff; }

        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: monospace;
            z-index: 100;
            text-align: center;
            pointer-events: none;
            display: none;
        }
    </style>
</head>
<body>

    <div id="loader">å•Ÿå‹•ç›¸æ©Ÿä¸­...<br><span style="color:#666; font-size: 0.8em;">è«‹å…è¨±ä½¿ç”¨æ¬Šé™</span></div>
    
    <div id="love-detected-msg" class="gesture-alert">â¤ï¸ åµæ¸¬åˆ°æ„›å¿ƒ â¤ï¸<br><span style="font-size:0.5em; color:white;">æ„›å¿ƒæ¨¹å·²ç”Ÿé•·</span></div>
    <div id="saturn-detected-msg" class="gesture-alert">ğŸª æ˜Ÿç³»å„€å•Ÿå‹• ğŸª<br><span style="font-size:0.5em; color:white;">å¤šé‡è»Œé“é‹è½‰ä¸­</span></div>
    <div id="wisdom-detected-msg" class="gesture-alert">ğŸ™ æ™ºæ…§åˆå ğŸ™<br><span style="font-size:0.5em; color:white;">çœŸç†èºæ—‹é¡¯ç¾</span></div>

    <button id="toggle-btn">/// é¸å–®</button>

    <div id="ui-panel">
        <h2>ç²’å­æ ¸å¿ƒæ§åˆ¶</h2>
        
        <div class="control-group">
            <label>ç³»çµ±è¨­å®š</label>
            <button id="camera-toggle" class="action-btn">å•Ÿç”¨ç›¸æ©Ÿ (é è¨­é—œé–‰)</button>
        </div>

        <div class="control-group">
            <label>æ¨¡æ“¬æ¨¡å¼</label>
            <div class="shape-grid">
                <button class="shape-btn active" data-shape="energy_orb">
                    <span class="btn-icon">ğŸ”®</span> 
                    <div>èƒ½é‡å…‰çƒ<br><span style="font-size:0.7em; color:#888;">å‡èšçˆ†ç™¼</span></div>
                </button>
                <button class="shape-btn" data-shape="heart">
                    <span class="btn-icon">â¤ï¸</span> 
                    <div>æ„›å¿ƒ<br><span style="font-size:0.7em; color:#888;">æ¯”å¿ƒè§¸ç™¼æ¨¹</span></div>
                </button>
                <button class="shape-btn" data-shape="saturn">
                    <span class="btn-icon">ğŸª</span> 
                    <div>åœŸæ˜Ÿ<br><span style="font-size:0.7em; color:#888;">OKæ‰‹å‹¢æ˜Ÿç³»</span></div>
                </button>
                <button class="shape-btn" data-shape="wisdom_fountain">
                    <span class="btn-icon">â›²</span> 
                    <div>æ™ºæ…§æ³‰<br><span style="font-size:0.7em; color:#888;">å™´æ³‰ç€‘å¸ƒ</span></div>
                </button>
            </div>
        </div>

        <div class="control-group">
            <label>ç²’å­å¯†åº¦ (ä¸Šé™ 200k)</label>
            <select id="particle-count-select">
                <option value="50000">æµæš¢ (50k)</option>
                <option value="100000" selected>é«˜ç•«è³ª (100k)</option>
                <option value="200000">æ¥µè‡´ (200k)</option>
            </select>
        </div>

        <div class="control-group">
            <label>è¦–è§’ç¸®æ”¾ (Zoom Level) <span id="zoom-val">1.0</span></label>
            <input type="range" id="zoom-slider" min="0.1" max="3.0" step="0.1" value="0.8">
        </div>

        <div class="control-group">
            <label>ç²’å­é¡è‰²</label>
            <input type="color" id="color-picker" value="#00ffff">
        </div>

        <div id="energy-bar-container">
            <div id="energy-bar"></div>
        </div>

        <div id="status">
            <div class="dot" id="cam-dot"></div>
            <span id="status-text">ç³»çµ±å¾…æ©Ÿä¸­</span>
        </div>

        <div style="margin-top: 15px; font-size: 0.7rem; color: #555; line-height: 1.6;">
            <strong>æ“ä½œèªªæ˜:</strong><br>
            [ç›¸æ©Ÿ] éœ€å…ˆåˆ‡æ›è‡³å°æ‡‰æ¨¡å¼<br>
            [æ„›å¿ƒæ¨¡å¼] æ¯”å¿ƒ -> æ„›å¿ƒæ¨¹<br>
            [é•·æŒ‰å·¦éµ / æ¡æ‹³] äº’å‹•/è“„åŠ›<br>
            [æ”¾é–‹] è§¸ç™¼ç‰¹æ•ˆ
        </div>
    </div>

    <div id="canvas-container"></div>
    
    <div id="camera-wrapper">
        <video id="video-feed" playsinline></video>
        <canvas id="output-canvas"></canvas>
    </div>

    <script>
        // --- æ ¸å¿ƒé…ç½® ---
        const MAX_PARTICLE_COUNT = 200000;
        let currentParticleCount = 100000;
        const PARTICLE_SIZE = 0.18;
        const MORPH_SPEED = 0.08;
        let CURRENT_SHAPE = 'energy_orb';
        let BASE_COLOR = new THREE.Color(0x00ffff);
        
        let targetTension = 0.5;
        let currentTension = 0.5;
        let isHandDetected = false;
        let isMouseDown = false;
        let isCameraEnabled = false;
        
        // æ‰‹å‹¢ç‹€æ…‹
        let isHeartGesture = false; 
        let isSaturnGesture = false; 
        let isWisdomGesture = false; 
        
        // ç‰¹æ•ˆç‹€æ…‹æ¨™è¨˜
        let showHeartTree = false;
        let showSaturnSpecial = false; 
        
        let mouseCoords = new THREE.Vector2(0, 0); 
        let targetFollowPos = new THREE.Vector2(0, 0); 
        
        let zoomLevel = 0.8;
        
        let energyCharge = 0; 
        let isExploding = false;
        let explosionTimer = 0; 
        let holdTime = 0; 
        let returnStrength = 0.0;
        
        const energyBar = document.getElementById('energy-bar');
        const energyBarContainer = document.getElementById('energy-bar-container');
        const countSelect = document.getElementById('particle-count-select');
        const colorPicker = document.getElementById('color-picker');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValDisplay = document.getElementById('zoom-val');
        const cameraToggleBtn = document.getElementById('camera-toggle');
        const cameraWrapper = document.getElementById('camera-wrapper');
        const outputCanvas = document.getElementById('output-canvas');
        const canvasCtx = outputCanvas.getContext('2d');
        const videoElement = document.getElementById('video-feed');
        const loader = document.getElementById('loader');
        
        const loveMsg = document.getElementById('love-detected-msg');
        const saturnMsg = document.getElementById('saturn-detected-msg');
        const wisdomMsg = document.getElementById('wisdom-detected-msg');

        document.getElementById('toggle-btn').addEventListener('click', (e) => {
            const panel = document.getElementById('ui-panel');
            panel.classList.toggle('closed');
            e.target.innerText = panel.classList.contains('closed') ? '/// é¡¯ç¤º' : '/// é¸å–®';
        });

        countSelect.addEventListener('change', (e) => {
            currentParticleCount = parseInt(e.target.value);
            geometry.setDrawRange(0, currentParticleCount);
            generateShape(CURRENT_SHAPE);
        });

        colorPicker.addEventListener('input', (e) => {
            BASE_COLOR.set(e.target.value);
        });

        zoomSlider.addEventListener('input', (e) => {
            zoomLevel = parseFloat(e.target.value);
            zoomValDisplay.innerText = zoomLevel.toFixed(1);
        });

        cameraToggleBtn.addEventListener('click', () => {
            isCameraEnabled = !isCameraEnabled;
            
            if (isCameraEnabled) {
                cameraToggleBtn.innerText = "åœæ­¢ç›¸æ©Ÿ";
                cameraToggleBtn.classList.add('active');
                cameraWrapper.style.display = 'block';
                loader.style.display = 'block';
                cameraFeed.start().then(() => {
                    loader.style.display = 'none';
                });
            } else {
                cameraToggleBtn.innerText = "å•Ÿç”¨ç›¸æ©Ÿ (é è¨­é—œé–‰)";
                cameraToggleBtn.classList.remove('active');
                cameraWrapper.style.display = 'none';
            }
        });

        function switchShape(shapeName) {
            CURRENT_SHAPE = shapeName;
            
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            const btn = document.querySelector(`.shape-btn[data-shape="${shapeName}"]`);
            if (btn) btn.classList.add('active');

            energyCharge = 0;
            isExploding = false;
            explosionTimer = 0;
            holdTime = 0;
            returnStrength = 0;
            
            if (shapeName === 'heart') showHeartTree = false;
            if (shapeName === 'saturn') showSaturnSpecial = false;
            
            energyBarContainer.style.display = 'block';
            
            generateShape(CURRENT_SHAPE);
        }

        document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const button = e.target.closest('.shape-btn');
                switchShape(button.dataset.shape);
            });
        });
        
        energyBarContainer.style.display = 'block';

        document.addEventListener('mousedown', () => isMouseDown = true);
        document.addEventListener('mouseup', () => isMouseDown = false);
        document.addEventListener('mousemove', (e) => {
            mouseCoords.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseCoords.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            if (!isHandDetected) {
                targetFollowPos.x = mouseCoords.x * 6;
                targetFollowPos.y = mouseCoords.y * 4;
            }
        });
        document.addEventListener('wheel', (e) => {
            let newZoom = zoomLevel + e.deltaY * -0.001;
            newZoom = Math.min(Math.max(0.1, newZoom), 3.0);
            zoomLevel = newZoom;
            zoomSlider.value = zoomLevel;
            zoomValDisplay.innerText = zoomLevel.toFixed(1);
        });

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.01);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.z = 15;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(MAX_PARTICLE_COUNT * 3);
        const velocities = new Float32Array(MAX_PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(MAX_PARTICLE_COUNT * 3); 
        const randomOffsets = new Float32Array(MAX_PARTICLE_COUNT * 3); 
        const explosionDirs = new Float32Array(MAX_PARTICLE_COUNT * 3);
        const colors = new Float32Array(MAX_PARTICLE_COUNT * 3); 

        for (let i = 0; i < MAX_PARTICLE_COUNT; i++) {
            const idx = i * 3;
            positions[idx] = 0; positions[idx+1] = 0; positions[idx+2] = 0;
            targetPositions[idx] = 0;
            
            const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            explosionDirs[idx] = v.x;
            explosionDirs[idx+1] = v.y;
            explosionDirs[idx+2] = v.z;

            randomOffsets[idx] = Math.random();
            randomOffsets[idx+1] = Math.random();
            randomOffsets[idx+2] = Math.random();

            colors[idx] = BASE_COLOR.r; 
            colors[idx+1] = BASE_COLOR.g; 
            colors[idx+2] = BASE_COLOR.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setDrawRange(0, currentParticleCount);

        const getTexture = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0.6)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.Texture(canvas);
        };
        const tex = getTexture();
        tex.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: PARTICLE_SIZE,
            map: tex,
            transparent: true,
            opacity: 0.9,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        function getPointInSphere(r) {
            const u = Math.random();
            const v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            const rad = r * Math.cbrt(Math.random());
            return [rad * Math.sin(phi) * Math.cos(theta), rad * Math.sin(phi) * Math.sin(theta), rad * Math.cos(phi)];
        }

        function generateShape(type) {
            for (let i = 0; i < currentParticleCount; i++) {
                const idx = i * 3;
                let x, y, z;
                
                if (type === 'heart') {
                    if (showHeartTree) {
                        if (randomOffsets[idx] < 0.15) {
                            const h = Math.random() * 6;
                            const r = 0.2 + (6-h)*0.1 + (Math.random()-0.5)*0.1;
                            const theta = Math.random() * Math.PI * 2;
                            x = r * Math.cos(theta);
                            y = h - 6;
                            z = r * Math.sin(theta);
                        } else {
                            const t = Math.random() * Math.PI * 2;
                            const distribution = (Math.random() + Math.random()) / 2; 
                            const r = 0.6 + distribution * 0.4; 
                            let hx = 16 * Math.pow(Math.sin(t), 3);
                            let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                            x = hx * 0.3 * r;
                            y = (hy * 0.3 * r) + 2; 
                            z = (Math.random() - 0.5) * 3 * r;
                        }
                    } else {
                        if (Math.random() < 0.4) {
                            const t = Math.random() * Math.PI * 2;
                            const distribution = (Math.random() + Math.random()) / 2; 
                            const r = 0.6 + distribution * 0.4; 
                            x = (16 * Math.pow(Math.sin(t), 3)) * 0.25 * r;
                            y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * 0.25 * r;
                            z = (Math.random() - 0.5) * 3 * r;
                        } else {
                            const r = 20 + Math.pow(Math.random(), 1.5) * 500; 
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos(2 * Math.random() - 1);
                            x = r * Math.sin(phi) * Math.cos(theta);
                            y = r * Math.sin(phi) * Math.sin(theta);
                            z = r * Math.cos(phi);
                        }
                    }
                } else if (type === 'saturn') {
                    if (Math.random() > 0.4) {
                        [x,y,z] = getPointInSphere(3);
                    } else {
                        const theta = Math.random() * Math.PI * 2;
                        const dist = 5 + Math.random() * 3;
                        x = dist * Math.cos(theta);
                        z = dist * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.3;
                        const yt = y * Math.cos(0.5) - z * Math.sin(0.5);
                        const zt = y * Math.sin(0.5) + z * Math.cos(0.5);
                        y = yt; z = zt;
                    }
                } else if (type === 'wisdom_fountain') {
                    // --- æ™ºæ…§æ³‰ (Wisdom Fountain) çµæ§‹é‡æ§‹ (ä»²é–€éˆæ„Ÿ) ---
                    // ä¿®æ”¹ï¼šå¢åŠ çµæ§‹é«”æ¯”ä¾‹è‡³ 40% (åŸ30%)ï¼Œä¸¦ç‰¹åˆ¥å¢åŠ æ­£æ–¹é«”å¯†åº¦
                    if (randomOffsets[idx] < 0.4) {
                        // === 40% çµæ§‹é«” ===
                        const structRand = Math.random();
                        
                        // 1. é•·æ–¹é«”æ°´æ±  (40% of struct)
                        if (structRand < 0.4) {
                            x = (Math.random() - 0.5) * 10.0;
                            z = (Math.random() - 0.5) * 6.0;
                            y = -2.5 + Math.random() * 0.5; // y: -2.5 ~ -2.0
                        } 
                        // 2. æ­£æ–¹é«”å°åº§ (35% of struct - å¤§å¹…å¢åŠ )
                        // å°ºå¯¸: 2x2x1.5 (ä½æ–¼æ°´æ± ä¸­å¿ƒ)
                        else if (structRand < 0.75) {
                            x = (Math.random() - 0.5) * 2.0;
                            z = (Math.random() - 0.5) * 2.0;
                            y = -2.0 + Math.random() * 1.5; // y: -2.0 ~ -0.5
                        }
                        // 3. é›™é›•å¡‘ (25% of struct) - æ‹‰è¿‘è·é›¢ï¼Œä¸è¦å‰‡å †ç–Š
                        else {
                            const isLeft = Math.random() > 0.5;
                            const offsetX = isLeft ? -0.4 : 0.4; 
                            
                            if (isLeft) {
                                const h = Math.random() * 5.0; 
                                const twist = Math.sin(h * 2.0) * 0.3;
                                const r = 0.4 - h * 0.05 + (Math.random()-0.5)*0.1;
                                const theta = Math.random() * Math.PI * 2;
                                x = offsetX + r * Math.cos(theta) + twist;
                                y = -0.5 + h; 
                                z = r * Math.sin(theta);
                            } else {
                                const h = Math.random() * 3.0;
                                const w = 0.4 + Math.random() * 0.3; 
                                const d = 0.4 + Math.random() * 0.3; 
                                x = offsetX + (Math.random()-0.5) * w;
                                y = -0.5 + h;
                                z = (Math.random()-0.5) * d;
                            }
                            x = Math.max(-0.9, Math.min(0.9, x));
                            z = Math.max(-0.9, Math.min(0.9, z));
                        }
                    } else {
                        // === 60% æ°´æº ===
                        // æ»¿ä½ˆæ–¼æ°´æ± ä¸­ (y ~ -2.0)
                        x = (Math.random() - 0.5) * 10.0;
                        z = (Math.random() - 0.5) * 6.0;
                        y = -2.0 + (Math.random()-0.5) * 0.2; 
                    }
                } else {
                    let r;
                    const rand = Math.random();
                    if (rand < 0.2) {
                        r = 5 + Math.random() * 35;
                    } else if (rand < 0.5) {
                        r = 40 + Math.random() * 160;
                    } else {
                        r = 200 + Math.pow(Math.random(), 1.5) * 2800;
                    }
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                }
                
                targetPositions[idx] = x;
                targetPositions[idx+1] = y;
                targetPositions[idx+2] = z;
                
                if(type === 'energy_orb') {
                     positions[idx] = x;
                     positions[idx+1] = y;
                     positions[idx+2] = z;
                }
            }
        }
        generateShape('energy_orb');

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5});
        
        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        hands.onResults((results) => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            canvasCtx.drawImage(results.image, 0, 0, outputCanvas.width, outputCanvas.height);
            
            isHeartGesture = false; 
            isSaturnGesture = false;
            isWisdomGesture = false;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                document.getElementById('cam-dot').classList.add('active');
                document.getElementById('status-text').innerText = "å·²åµæ¸¬æ‰‹éƒ¨";
                
                let tensionSum = 0;
                let handCenterX = 0;
                let handCenterY = 0;

                if (results.multiHandLandmarks.length === 2) {
                    const h1 = results.multiHandLandmarks[0];
                    const h2 = results.multiHandLandmarks[1];
                    const thumbDist = dist(h1[4], h2[4]);
                    const indexDist = dist(h1[8], h2[8]);
                    
                    if (thumbDist < 0.15 && indexDist < 0.15) {
                        isHeartGesture = true;
                    }

                    // --- ä¿®æ­£ï¼šå„ªåŒ–æ™ºæ…§åˆåæ‰‹å‹¢åµæ¸¬ ---
                    // 1. æ‰‹è…•è·é›¢ (0)
                    const wristDist = dist(h1[0], h2[0]);
                    // 2. æŒ‡å°–è·é›¢ (ä¸­æŒ‡12, å°æŒ‡20)
                    const middleDist = dist(h1[12], h2[12]);
                    const pinkyDist = dist(h1[20], h2[20]);
                    
                    // é‚è¼¯æ”¹é€²ï¼š
                    // A. æ¨™æº–åˆå (æ”¾å¯¬è·é›¢é™åˆ¶ï¼Œå¾ 0.20 -> 0.4)
                    // B. è“®èŠ±æ‰‹ (åªè¦æ‰‹è…•é åœ¨ä¸€èµ· < 0.25ï¼Œæ‰‹æŒ‡åˆ†é–‹ä¹Ÿç®—)
                    // C. å´é¢åˆå (æœ‰æ™‚å€™å°æŒ‡æ¯”ä¸­æŒ‡æ›´å®¹æ˜“è¢«åµæ¸¬åˆ°é è¿‘)
                    
                    if (
                        (wristDist < 0.4 && middleDist < 0.4) || // å¯¬é¬†åˆå
                        (wristDist < 0.4 && pinkyDist < 0.4) ||  // å´é¢åˆå
                        (wristDist < 0.25)                       // è“®èŠ±æ‰‹/æ‰‹è…•ç·Šè²¼
                    ) {
                        isWisdomGesture = true;
                    }
                } 
                
                results.multiHandLandmarks.forEach(lm => {
                    const fingerHeartDist = dist(lm[4], lm[8]);
                    const wristToMiddleTip = dist(lm[0], lm[12]);
                    const wristToMiddlePip = dist(lm[0], lm[10]);
                    const isMiddleExtended = wristToMiddleTip > wristToMiddlePip * 1.2;

                    if (fingerHeartDist < 0.08) {
                        if (isMiddleExtended) {
                            isSaturnGesture = true;
                        } else {
                            isHeartGesture = true;
                        }
                    }
                });

                if (CURRENT_SHAPE === 'heart' && isHeartGesture) {
                    loveMsg.style.opacity = 1;
                    saturnMsg.style.opacity = 0;
                    wisdomMsg.style.opacity = 0;
                    if (!showHeartTree) {
                        showHeartTree = true;
                        generateShape('heart');
                    }
                } 
                else if (CURRENT_SHAPE === 'saturn' && isSaturnGesture) {
                    saturnMsg.style.opacity = 1;
                    loveMsg.style.opacity = 0;
                    wisdomMsg.style.opacity = 0;
                    if (!showSaturnSpecial) {
                         showSaturnSpecial = true;
                    }
                } 
                else if (CURRENT_SHAPE === 'wisdom_fountain' && isWisdomGesture) {
                    wisdomMsg.style.opacity = 1;
                    loveMsg.style.opacity = 0;
                    saturnMsg.style.opacity = 0;
                } 
                else {
                    loveMsg.style.opacity = 0;
                    saturnMsg.style.opacity = 0;
                    wisdomMsg.style.opacity = 0;
                }

                results.multiHandLandmarks.forEach(lm => {
                    drawConnectors(canvasCtx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                    drawLandmarks(canvasCtx, lm, {color: '#FF0000', lineWidth: 1, radius: 3});
                    const wrist = lm[0];
                    let d = 0;
                    [4,8,12,16,20].forEach(i => {
                        d += Math.hypot(lm[i].x-wrist.x, lm[i].y-wrist.y, lm[i].z-wrist.z);
                    });
                    tensionSum += Math.max(0, Math.min(1, (d/5 - 0.1) * 3));
                    handCenterX += wrist.x;
                    handCenterY += wrist.y;
                });

                handCenterX /= results.multiHandLandmarks.length;
                handCenterY /= results.multiHandLandmarks.length;

                const ndcX = (handCenterX - 0.5) * 2; 
                const ndcY = -(handCenterY - 0.5) * 2;

                targetFollowPos.x = -ndcX * 6; 
                targetFollowPos.y = ndcY * 4;

                targetTension = tensionSum / results.multiHandLandmarks.length;
            } else {
                isHandDetected = false;
                isHeartGesture = false;
                isSaturnGesture = false;
                isWisdomGesture = false;
                loveMsg.style.opacity = 0;
                saturnMsg.style.opacity = 0;
                wisdomMsg.style.opacity = 0;
                document.getElementById('cam-dot').classList.remove('active');
                document.getElementById('status-text').innerText = "æœªåµæ¸¬åˆ°";
                targetTension = 0.5;
            }
            canvasCtx.restore();
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                if(isCameraEnabled) {
                    await hands.send({image: videoElement});
                }
            },
            width: 320, height: 240
        });
        
        outputCanvas.width = 320;
        outputCanvas.height = 240;

        let time = 0;
        let heartBeatTime = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            let tension = targetTension;
            if (isMouseDown) tension = 0; 
            currentTension += (tension - currentTension) * 0.1;
            
            const isInteracting = tension < 0.3 || isHeartGesture || isWisdomGesture;

            let followSpeed = 0.05; 
            let followAmp = 1.0;    
            if (zoomLevel < 0.5) {
                followAmp = 1.0 / Math.max(zoomLevel, 0.2); 
            }

            particleSystem.position.x += (targetFollowPos.x * followAmp * 0.5 - particleSystem.position.x) * followSpeed;
            particleSystem.position.y += (targetFollowPos.y * followAmp * 0.5 - particleSystem.position.y) * followSpeed;
            
            particleSystem.scale.setScalar(zoomLevel);

            if (CURRENT_SHAPE === 'energy_orb') {
                // ... (Energy Orb Logic unchanged) ...
                particleSystem.rotation.y += 0.0005; 
                if (isInteracting) {
                    holdTime += 0.016; 
                    energyCharge += 0.008; 
                    if(energyCharge > 1) energyCharge = 1;
                    isExploding = false;
                    returnStrength = 0; 
                } else {
                    if (energyCharge > 0.2) {
                        isExploding = true;
                        explosionTimer = 8.0; 
                    }
                    energyCharge -= 0.02; 
                    if(energyCharge < 0) energyCharge = 0;
                    holdTime = 0; 
                }
                energyBar.style.width = `${energyCharge * 100}%`;
                
                let radiusMultiplier = 1.0;
                if (zoomLevel < 0.5) radiusMultiplier = 0.5 / Math.max(zoomLevel, 0.1); 
                const currentRadius = (4.0 + energyCharge * 4.0) * radiusMultiplier; 

                if (isExploding) {
                    explosionTimer -= 0.01;
                    if (explosionTimer < 0) isExploding = false; 
                }

                for (let i = 0; i < currentParticleCount; i++) {
                    const idx = i * 3;
                    const isBackgroundStar = randomOffsets[idx] < 0.3; 
                    if (isExploding) {
                        if (!isBackgroundStar) {
                            if (explosionTimer > 0) {
                                const cinematicSlowMo = 0.3;
                                let zoomSpeedBooster = 1.0;
                                if (zoomLevel < 1.0) zoomSpeedBooster = 1.0 / Math.max(zoomLevel, 0.15);
                                const randomVal = Math.random();
                                const randomSpeed = Math.pow(randomVal, 10.0); 
                                const speedBase = 0.02 + randomSpeed * 0.8; 
                                const speed = speedBase * (1 + energyCharge * 2.0) * cinematicSlowMo * zoomSpeedBooster;
                                velocities[idx] = explosionDirs[idx] * speed;
                                velocities[idx+1] = explosionDirs[idx+1] * speed;
                                velocities[idx+2] = explosionDirs[idx+2] * speed;
                            }
                            pos[idx] += velocities[idx];
                            pos[idx+1] += velocities[idx+1];
                            pos[idx+2] += velocities[idx+2];
                            velocities[idx] *= 0.99; 
                        } else {
                             pos[idx] += (Math.random()-0.5) * 0.05;
                             pos[idx+1] += (Math.random()-0.5) * 0.05;
                             pos[idx+2] += (Math.random()-0.5) * 0.05;
                        }
                        col[idx] = THREE.MathUtils.lerp(col[idx], BASE_COLOR.r, 0.02);
                        col[idx+1] = THREE.MathUtils.lerp(col[idx+1], BASE_COLOR.g, 0.02);
                        col[idx+2] = THREE.MathUtils.lerp(col[idx+2], BASE_COLOR.b, 0.02);
                    } else if (energyCharge > 0.01) {
                        if (isBackgroundStar) {
                            const tx = targetPositions[idx];
                            const ty = targetPositions[idx+1];
                            const tz = targetPositions[idx+2];
                            pos[idx] += (tx - pos[idx]) * 0.05;
                            pos[idx+1] += (ty - pos[idx+1]) * 0.05;
                            pos[idx+2] += (tz - pos[idx+2]) * 0.05;
                            col[idx] = BASE_COLOR.r + Math.random() * 0.5;
                            col[idx+1] = BASE_COLOR.g + Math.random() * 0.5;
                            col[idx+2] = BASE_COLOR.b + Math.random() * 0.5;
                        } else {
                            let shake = Math.pow(energyCharge, 2.5) * 10.0;
                            if (holdTime > 10) {
                                const extremeFactor = (holdTime - 10) * 2.0; 
                                shake += extremeFactor * 5.0; 
                            }
                            if (zoomLevel < 0.6) shake *= (1.5 / Math.max(zoomLevel, 0.1));
                            let tx, ty, tz;
                            if (randomOffsets[idx] > 0.65) { 
                                const r = currentRadius * (0.95 + Math.random()*0.1); 
                                tx = explosionDirs[idx] * r;
                                ty = explosionDirs[idx+1] * r;
                                tz = explosionDirs[idx+2] * r;
                            } else {
                                const r = currentRadius * Math.random() * 0.9; 
                                tx = explosionDirs[idx] * r;
                                ty = explosionDirs[idx+1] * r;
                                tz = explosionDirs[idx+2] * r;
                                tx += (Math.random()-0.5) * shake;
                                ty += (Math.random()-0.5) * shake;
                                tz += (Math.random()-0.5) * shake;
                            }
                            const pullSpeed = 0.03 + energyCharge * 0.05; 
                            pos[idx] += (tx - pos[idx]) * pullSpeed;
                            pos[idx+1] += (ty - pos[idx+1]) * pullSpeed;
                            pos[idx+2] += (tz - pos[idx+2]) * pullSpeed;
                            velocities[idx] = 0; velocities[idx+1] = 0; velocities[idx+2] = 0;
                            col[idx] = THREE.MathUtils.lerp(BASE_COLOR.r, 1.0, energyCharge);
                            col[idx+1] = THREE.MathUtils.lerp(BASE_COLOR.g, 1.0, energyCharge);
                            col[idx+2] = THREE.MathUtils.lerp(BASE_COLOR.b, 1.0, energyCharge);
                        }
                    } else {
                        returnStrength += 0.00005; 
                        const smoothReturn = Math.min(returnStrength, 0.02);
                        const tx = targetPositions[idx];
                        const ty = targetPositions[idx+1];
                        const tz = targetPositions[idx+2];
                        pos[idx] += (tx - pos[idx]) * smoothReturn;
                        pos[idx+1] += (ty - pos[idx+1]) * smoothReturn;
                        pos[idx+2] += (tz - pos[idx+2]) * smoothReturn;
                        pos[idx] += Math.sin(time + idx * 0.1) * 0.02;
                        pos[idx+1] += Math.cos(time + idx * 0.1) * 0.02;
                        col[idx] = THREE.MathUtils.lerp(col[idx], BASE_COLOR.r, 0.05);
                        col[idx+1] = THREE.MathUtils.lerp(col[idx+1], BASE_COLOR.g, 0.05);
                        col[idx+2] = THREE.MathUtils.lerp(col[idx+2], BASE_COLOR.b, 0.05);
                    }
                }

            } else if (CURRENT_SHAPE === 'heart') {
                // ... (Heart Logic unchanged) ...
                particleSystem.rotation.y += isInteracting ? 0.05 : 0.005;
                if (isInteracting) {
                    energyCharge += 0.01; 
                    if(energyCharge > 1) energyCharge = 1;
                    isExploding = false; 
                    explosionTimer = 0;  
                    heartBeatTime += 0.2 + energyCharge * 0.6;
                    const beat = Math.pow(Math.sin(heartBeatTime), 60) * 0.3 + 1.0; 
                    particleSystem.scale.setScalar(zoomLevel * beat); 
                } else {
                    if (energyCharge > 0.3) {
                        isExploding = true;
                        explosionTimer = 3.0; // èŠ±ç“£é£„æ•£æ™‚é–“
                    }
                    energyCharge -= 0.05;
                    if(energyCharge < 0) energyCharge = 0;
                    particleSystem.scale.setScalar(zoomLevel);
                }
                energyBar.style.width = `${energyCharge * 100}%`;

                if (showHeartTree) {
                    if (isInteracting) {
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            if (randomOffsets[idx] < 0.15) {
                                col[idx] = 0.8; col[idx+1] = 0.6; col[idx+2] = 0.2;
                            } else {
                                col[idx] = THREE.MathUtils.lerp(col[idx], 1.0, 0.1); 
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.4, 0.1);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.6, 0.1);
                                if (Math.random() < 0.1) {
                                    pos[idx] += (Math.random()-0.5) * 0.1;
                                    pos[idx+1] += (Math.random()-0.5) * 0.1;
                                    pos[idx+2] += (Math.random()-0.5) * 0.1;
                                }
                            }
                        }
                    } else if (isExploding) {
                        explosionTimer -= 0.015; 
                        if(explosionTimer < 0) isExploding = false;
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            if (randomOffsets[idx] >= 0.15) { 
                                if(explosionTimer > 2.8) {
                                    velocities[idx] = (Math.random()-0.5) * 0.3;
                                    velocities[idx+1] = (Math.random()) * 0.3; 
                                    velocities[idx+2] = (Math.random()-0.5) * 0.3;
                                }
                                pos[idx] += velocities[idx];
                                pos[idx+1] += velocities[idx+1];
                                pos[idx+2] += velocities[idx+2];
                                velocities[idx] *= 0.96; 
                                velocities[idx+1] -= 0.003; 
                                pos[idx] += Math.sin(time * 5 + idx) * 0.02;
                            }
                        }
                    } else {
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            if (randomOffsets[idx] < 0.15) {
                                col[idx] = THREE.MathUtils.lerp(col[idx], 0.6, 0.05);
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.4, 0.05);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.1, 0.05);
                            } else {
                                col[idx] = THREE.MathUtils.lerp(col[idx], 1.0, 0.05);
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.7, 0.05);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.8, 0.05);
                            }
                            const tx = targetPositions[idx];
                            const ty = targetPositions[idx+1];
                            const tz = targetPositions[idx+2];
                            pos[idx] += (tx - pos[idx]) * MORPH_SPEED;
                            pos[idx+1] += (ty - pos[idx+1]) * MORPH_SPEED;
                            pos[idx+2] += (tz - pos[idx+2]) * MORPH_SPEED;
                        }
                    }
                } else {
                    if (isInteracting) {
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            col[idx] = THREE.MathUtils.lerp(col[idx], 1.0, 0.1); 
                            col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.0, 0.1);
                            col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.2, 0.1);
                            if (Math.random() < 0.1) {
                                pos[idx] += (Math.random()-0.5) * 0.2;
                                pos[idx+1] += (Math.random()-0.5) * 0.2;
                                pos[idx+2] += (Math.random()-0.5) * 0.2;
                            }
                        }
                    } else if (isExploding) {
                        explosionTimer -= 0.015;
                        if(explosionTimer < 0) isExploding = false;
                        const duration = 3.0;
                        const progress = 1.0 - Math.max(0, explosionTimer / duration);
                        const arrowX = -25 + progress * 50; 
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            if (i % 5 === 0) {
                                const rnd = randomOffsets[idx];
                                let ax, ay, az;
                                if (rnd < 0.6) { 
                                    ax = (rnd / 0.6) * 4 - 2; 
                                    ay = 0; az = 0;
                                } else if (rnd < 0.8) { 
                                    const t = (rnd - 0.6) / 0.2; 
                                    ax = 2 + t * 1.5; 
                                    ay = (1-t) * 0.8 * Math.cos(i);
                                    az = (1-t) * 0.8 * Math.sin(i);
                                } else { 
                                    const t = (rnd - 0.8) / 0.2;
                                    ax = -2 - t * 1.5;
                                    ay = t * 1.0 * Math.cos(i);
                                    az = t * 1.0 * Math.sin(i); 
                                }
                                const targetX = ax + arrowX;
                                pos[idx] += (targetX - pos[idx]) * 0.3;
                                pos[idx+1] += (ay - pos[idx+1]) * 0.3;
                                pos[idx+2] += (az - pos[idx+2]) * 0.3;
                                col[idx] = 1.0; col[idx+1] = 0.9; col[idx+2] = 0.4;
                            } else {
                                const tx = targetPositions[idx];
                                const ty = targetPositions[idx+1];
                                const tz = targetPositions[idx+2];
                                const distToArrowPlane = Math.abs(tx - arrowX);
                                let push = 0;
                                if (distToArrowPlane < 2.0) {
                                    push = (2.0 - distToArrowPlane) * 2.5; 
                                }
                                const dirY = ty > 0 ? 1 : -1;
                                const dirZ = tz > 0 ? 1 : -1;
                                pos[idx] += (tx - pos[idx]) * 0.1; 
                                pos[idx+1] += (ty + dirY * push - pos[idx+1]) * 0.1;
                                pos[idx+2] += (tz + dirZ * push - pos[idx+2]) * 0.1;
                                col[idx] = THREE.MathUtils.lerp(col[idx], BASE_COLOR.r, 0.1);
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], BASE_COLOR.g, 0.1);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], BASE_COLOR.b, 0.1);
                            }
                        }
                    } else {
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            col[idx] = THREE.MathUtils.lerp(col[idx], BASE_COLOR.r, 0.05);
                            col[idx+1] = THREE.MathUtils.lerp(col[idx+1], BASE_COLOR.g, 0.05);
                            col[idx+2] = THREE.MathUtils.lerp(col[idx+2], BASE_COLOR.b, 0.05);
                            const tx = targetPositions[idx];
                            const ty = targetPositions[idx+1];
                            const tz = targetPositions[idx+2];
                            pos[idx] += (tx - pos[idx]) * MORPH_SPEED;
                            pos[idx+1] += (ty - pos[idx+1]) * MORPH_SPEED;
                            pos[idx+2] += (tz - pos[idx+2]) * MORPH_SPEED;
                        }
                    }
                }
            } else if (CURRENT_SHAPE === 'saturn') {
                // ... (Saturn Logic unchanged) ...
                const baseRot = 0.003;
                // æŒ‰ä¸‹éœ€åŠ é€Ÿæ—‹è½‰
                particleSystem.rotation.y += baseRot + (isInteracting ? 0.05 + energyCharge * 0.2 : 0);
                
                if (!isInteracting) {
                    particleSystem.rotation.z = Math.sin(time * 0.2) * 0.1; 
                }

                if (isInteracting) {
                    energyCharge += 0.01;
                    if (energyCharge > 1) energyCharge = 1;
                    isExploding = false;
                    explosionTimer = 0;
                } else {
                    if (energyCharge > 0.3) {
                        isExploding = true;
                        explosionTimer = 4.0; 
                    }
                    energyCharge -= 0.02;
                    if (energyCharge < 0) energyCharge = 0;
                }
                
                energyBar.style.width = `${energyCharge * 100}%`;

                if (showSaturnSpecial) {
                     // ... æ˜Ÿç³»å„€é‚è¼¯ä¿æŒä¸è®Š ...
                     for (let i = 0; i < currentParticleCount; i++) {
                        const idx = i * 3;
                        const rnd = randomOffsets[idx];
                        const isBody = rnd > 0.5;
                        let tx, ty, tz;
                        if (isBody) {
                             [tx, ty, tz] = [targetPositions[idx], targetPositions[idx+1], targetPositions[idx+2]];
                             tx *= 0.8; ty *= 0.8; tz *= 0.8;
                             col[idx] = THREE.MathUtils.lerp(col[idx], 1.0, 0.1); 
                             col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.9, 0.1); 
                             col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.5, 0.1); 
                        } else {
                            const ringGroup = Math.floor(rnd * 6) % 3; 
                            const angle = time * (2.0 + ringGroup) + idx * 0.01; 
                            const radius = 6.0 + Math.sin(time * 2 + idx) * 0.5; 
                            if (ringGroup === 0) { 
                                tx = Math.cos(angle) * radius;
                                ty = Math.sin(angle) * radius;
                                tz = (Math.random()-0.5) * 0.5;
                                col[idx] = 0.0; col[idx+1] = 1.0; col[idx+2] = 1.0;
                            } else if (ringGroup === 1) { 
                                tx = (Math.random()-0.5) * 0.5;
                                ty = Math.cos(angle) * radius;
                                tz = Math.sin(angle) * radius;
                                col[idx] = 1.0; col[idx+1] = 0.0; col[idx+2] = 1.0;
                            } else { 
                                tx = Math.cos(angle) * radius;
                                ty = (Math.random()-0.5) * 0.5;
                                tz = Math.sin(angle) * radius;
                                col[idx] = 1.0; col[idx+1] = 0.8; col[idx+2] = 0.0;
                            }
                        }
                        pos[idx] += (tx - pos[idx]) * 0.1; 
                        pos[idx+1] += (ty - pos[idx+1]) * 0.1;
                        pos[idx+2] += (tz - pos[idx+2]) * 0.1;
                    }
                } else {
                    if (isExploding) {
                        explosionTimer -= 0.02;
                        if (explosionTimer < 0) isExploding = false;
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            const isBody = randomOffsets[idx] > 0.5;
                            if (!isBody) {
                                if (explosionTimer > 3.0) { 
                                    velocities[idx] = pos[idx] * 0.05; 
                                    velocities[idx+1] = pos[idx+1] * 0.05; 
                                    velocities[idx+2] = pos[idx+2] * 0.05; 
                                }
                                pos[idx] += velocities[idx];
                                pos[idx+1] += velocities[idx+1];
                                pos[idx+2] += velocities[idx+2];
                                velocities[idx] *= 0.95; 
                                col[idx] = THREE.MathUtils.lerp(col[idx], 1.0, 0.1);
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 1.0, 0.1);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 1.0, 0.1);
                            } else {
                                 pos[idx] += (Math.random()-0.5) * 0.2;
                                 pos[idx+1] += (Math.random()-0.5) * 0.2;
                                 pos[idx+2] += (Math.random()-0.5) * 0.2;
                                 const tx = targetPositions[idx];
                                 const ty = targetPositions[idx+1];
                                 const tz = targetPositions[idx+2];
                                 pos[idx] += (tx - pos[idx]) * 0.1;
                                 pos[idx+1] += (ty - pos[idx+1]) * 0.1;
                                 pos[idx+2] += (tz - pos[idx+2]) * 0.1;
                            }
                        }
                    } else {
                        for (let i = 0; i < currentParticleCount; i++) {
                            const idx = i * 3;
                            const isBody = randomOffsets[idx] > 0.5;
                            let tx = targetPositions[idx];
                            let ty = targetPositions[idx+1];
                            let tz = targetPositions[idx+2];

                            if (isInteracting) {
                                if (isBody) {
                                    tx *= (1.0 - energyCharge * 0.3);
                                    ty *= (1.0 - energyCharge * 0.3);
                                    tz *= (1.0 - energyCharge * 0.3);
                                    col[idx] = THREE.MathUtils.lerp(col[idx], 0.1, 0.05); 
                                    col[idx+1] = THREE.MathUtils.lerp(col[idx+1], 0.0, 0.05); 
                                    col[idx+2] = THREE.MathUtils.lerp(col[idx+2], 0.2, 0.05); 
                                } else {
                                    tx += (Math.random()-0.5) * energyCharge * 0.5;
                                    ty += (Math.random()-0.5) * energyCharge * 0.5;
                                    tz += (Math.random()-0.5) * energyCharge * 0.5;
                                    
                                    // è®Šè‰²é‚è¼¯ï¼šé è¨­ -> éœ“è™¹ -> é‡‘è‰²
                                    let r_t, g_t, b_t;
                                    if (energyCharge < 0.2) {
                                        // åˆå§‹éšæ®µ (0-20%)ï¼šå¾ BASE_COLOR é–‹å§‹è®Š
                                        r_t = BASE_COLOR.r; g_t = BASE_COLOR.g; b_t = BASE_COLOR.b;
                                    } else if (energyCharge < 0.85) {
                                        // éœ“è™¹éšæ®µ (20-85%)
                                        const freq = 0.0002;
                                        const speed = 8.0 + energyCharge * 10.0;
                                        const phase = time * speed + idx * freq;
                                        r_t = 0.5 + 0.5 * Math.sin(phase);
                                        g_t = 0.5 + 0.5 * Math.sin(phase + 2.094);
                                        b_t = 0.5 + 0.5 * Math.sin(phase + 4.188);
                                    } else {
                                        // é‡‘è‰²éšæ®µ (>85%)
                                        r_t = 1.0; g_t = 0.84; b_t = 0.0;
                                    }
                                    
                                    // ä½¿ç”¨ lerp å¹³æ»‘éæ¸¡åˆ°ç›®æ¨™é¡è‰²
                                    col[idx] = THREE.MathUtils.lerp(col[idx], r_t, 0.1);
                                    col[idx+1] = THREE.MathUtils.lerp(col[idx+1], g_t, 0.1);
                                    col[idx+2] = THREE.MathUtils.lerp(col[idx+2], b_t, 0.1);
                                }
                            } else {
                                // é–’ç½®å›æ­¸é è¨­è‰²
                                col[idx] = THREE.MathUtils.lerp(col[idx], BASE_COLOR.r, 0.05);
                                col[idx+1] = THREE.MathUtils.lerp(col[idx+1], BASE_COLOR.g, 0.05);
                                col[idx+2] = THREE.MathUtils.lerp(col[idx+2], BASE_COLOR.b, 0.05);
                            }
                            
                            pos[idx] += (tx - pos[idx]) * MORPH_SPEED;
                            pos[idx+1] += (ty - pos[idx+1]) * MORPH_SPEED;
                            pos[idx+2] += (tz - pos[idx+2]) * MORPH_SPEED;
                        }
                    }
                }
            } else if (CURRENT_SHAPE === 'wisdom_fountain') {
                // --- æ™ºæ…§æ³‰ (Wisdom Fountain) ç‰©ç†é‚è¼¯ ---
                
                // é›•åƒæœ¬é«”è‡ªè½‰
                particleSystem.rotation.y += 0.002 + (isInteracting ? 0.02 : 0);

                if (isInteracting) {
                    energyCharge += 0.01;
                    if (energyCharge > 1) energyCharge = 1;
                    isExploding = false;
                } else {
                    // æ”¾æ‰‹è§¸ç™¼å¤§å™´ç™¼
                    if (energyCharge > 0.2) {
                         isExploding = true;
                         explosionTimer = 4.0;
                    }
                    energyCharge -= 0.05;
                    if (energyCharge < 0) energyCharge = 0;
                }
                
                energyBar.style.width = `${energyCharge * 100}%`;

                // æ§åˆ¶å™´æ³‰åƒæ•¸
                const flowIntensity = energyCharge; 
                // isExploding æ™‚ï¼Œå¤§å™´ç™¼å…¨é–‹

                for (let i = 0; i < currentParticleCount; i++) {
                    const idx = i * 3;
                    // --- æ™ºæ…§æ³‰é‚è¼¯ä¿®æ­£ï¼šå¢åŠ æ­£æ–¹é«”åŸºåº§æ¯”ä¾‹ ---
                    // æ ¹æ“š generateShape çš„æ¯”ä¾‹:
                    // çµæ§‹ < 0.4
                    //   - é•·æ–¹é«”æ°´æ±  < 0.4 (16% of total)
                    //   - æ­£æ–¹é«”å°åº§ < 0.75 (14% of total)
                    //   - é›™é›•å¡‘ else (10% of total)
                    const rnd = randomOffsets[idx];
                    
                    const isStructure = rnd < 0.4;

                    if (isStructure) {
                        // === é›•åƒèˆ‡åŸºåº§ (éœæ…‹) ===
                        const tx = targetPositions[idx];
                        const ty = targetPositions[idx+1];
                        const tz = targetPositions[idx+2];
                        
                        pos[idx] += (tx - pos[idx]) * MORPH_SPEED;
                        pos[idx+1] += (ty - pos[idx+1]) * MORPH_SPEED;
                        pos[idx+2] += (tz - pos[idx+2]) * MORPH_SPEED;
                        
                        // é¡è‰²é‚è¼¯ç´°åˆ†
                        if (rnd < 0.4 * 0.4) {
                            // é•·æ–¹é«”æ°´æ±  (æ·±çŸ³è‰²)
                            col[idx] = 0.4; col[idx+1] = 0.4; col[idx+2] = 0.4;
                        } else if (rnd < 0.4 * 0.75) {
                            // æ­£æ–¹é«”åŸºåº§ (æ·ºçŸ³è‰²)
                            col[idx] = 0.7; col[idx+1] = 0.65; col[idx+2] = 0.6;
                        } else {
                            // é›™é›•å¡‘ (æ·±éŠ…è‰²)
                            col[idx] = 0.55; col[idx+1] = 0.35; col[idx+2] = 0.2;
                        }

                    } else {
                        // === æ°´ç²’å­ (å‹•æ…‹) ===
                        
                        if (isExploding) {
                            // --- ä¿®æ­£: é‚„åŸç‚ºç€‘å¸ƒæ¨¡å¼ (å¾é‚Šç·£è½ä¸‹) ---
                            // ç€‘å¸ƒè¨ˆæ™‚å™¨
                            if(i==0) explosionTimer -= 0.01; // åªæ¸›ä¸€æ¬¡
                            if(explosionTimer < 0) isExploding = false;
                            
                            // ç€‘å¸ƒæºé ­ï¼šåº•åº§å¹³é¢é™„è¿‘ (y ~ -2.0)
                            // éš¨æ©Ÿé‡ç½®ä½ç½®åˆ°ä¸Šæ–¹ï¼Œå½¢æˆé€£çºŒæ°´æµ
                            if (pos[idx+1] < -10.0 || Math.random() < 0.05) {
                                // åœ¨åº•åº§ç¯„åœå…§éš¨æ©Ÿç”Ÿæˆ
                                // é•·æ–¹é«”åº•åº§é‚Šç·£: x: +/-4, z: +/-2 (æ ¹æ“š generateShape å®šç¾©)
                                
                                // éš¨æ©Ÿé¸æ“‡å››å€‹é‚Šç·£ä¹‹ä¸€
                                const edge = Math.floor(Math.random() * 4);
                                let startX, startZ;
                                
                                // æ°´æ± å¯¬ 10, æ·± 6 (åŠå¾‘ 5, 3)
                                if (edge === 0) { // å‰
                                    startX = (Math.random()-0.5) * 10.0;
                                    startZ = 3.0;
                                } else if (edge === 1) { // å¾Œ
                                    startX = (Math.random()-0.5) * 10.0;
                                    startZ = -3.0;
                                } else if (edge === 2) { // å·¦
                                    startX = -5.0;
                                    startZ = (Math.random()-0.5) * 6.0;
                                } else { // å³
                                    startX = 5.0;
                                    startZ = (Math.random()-0.5) * 6.0;
                                }
                                
                                pos[idx] = startX;
                                pos[idx+1] = -2.0; // å¾åº•åº§é‚Šç·£é«˜åº¦è½ä¸‹
                                pos[idx+2] = startZ;
                                
                                velocities[idx] = 0;
                                velocities[idx+1] = -0.1 - Math.random() * 0.2; // å‘ä¸‹åˆé€Ÿ
                                velocities[idx+2] = 0;
                            }
                            
                            // é‡åŠ›åŠ é€Ÿ
                            velocities[idx+1] -= 0.05; 
                            
                            pos[idx] += velocities[idx];
                            pos[idx+1] += velocities[idx+1];
                            pos[idx+2] += velocities[idx+2];
                            
                            // é¡è‰²ï¼šæ·±è—è‰²ç€‘å¸ƒ
                            col[idx] = 0.0; col[idx+1] = 0.1; col[idx+2] = 0.6;

                        } else if (flowIntensity > 0.05) {
                            // --- é€£çºŒå™´æ³‰æ¨¡å¼ (ä¿®æ­£ï¼šéš¨é•·æŒ‰å¢é«˜ï¼Œè¶…éé›•å¡‘) ---
                            // ä¿®æ­£ï¼šå¾é•·æ–¹é«”ç¯„åœéš¨æ©Ÿå™´å‡º
                            
                            // å¦‚æœç²’å­è½å›åº•åº§ (y < -2.5) æˆ–é£›å¤ªé ï¼Œé‡ç½®ç™¼å°„
                            if (pos[idx+1] < -2.5) {
                                // é‡ç½®åˆ°æ°´æ± è¡¨é¢ä»»æ„ä½ç½®
                                const poolW = 8.0;
                                const poolD = 4.0;
                                pos[idx] = (Math.random()-0.5) * poolW;
                                pos[idx+1] = -2.0; 
                                pos[idx+2] = (Math.random()-0.5) * poolD;
                                
                                // --- ä¿®æ”¹é»ï¼šç§»é™¤é«˜åº¦é™åˆ¶ï¼Œéš¨èƒ½é‡å¤§å¹…å¢é«˜ ---
                                // é›•å¡‘æœ€é«˜é»ç´„ y = 4.5 (åŸºåº§ -2.0) -> éœ€è¦é«˜åº¦å·® > 6.5
                                // æ ¹æ“š h = v^2 / 2g (g=0.01) -> v ~ 0.36 å¯é”é«˜åº¦ 6.5
                                // è¨­å®šé€Ÿåº¦ç¯„åœï¼š0.1 (ä½æ¹§) ~ 0.5 (é«˜å™´ï¼Œè¶…éé›•å¡‘)
                                
                                const speedY = 0.1 + flowIntensity * 0.4 + Math.random() * 0.1;
                                
                                // æ“´æ•£ç¯„åœä¹Ÿéš¨åŠ›åº¦å¢åŠ  (å™´å¾—æ›´é )
                                const spread = 0.02 + flowIntensity * 0.08;
                                
                                velocities[idx] = (Math.random()-0.5) * spread;
                                velocities[idx+1] = speedY; 
                                velocities[idx+2] = (Math.random()-0.5) * spread;
                                
                                pos[idx+1] += Math.random() * 0.2;
                            }
                            
                            velocities[idx+1] -= 0.01;
                            
                            pos[idx] += velocities[idx];
                            pos[idx+1] += velocities[idx+1];
                            pos[idx+2] += velocities[idx+2];
                            
                            // é¡è‰²ï¼šéš¨é«˜åº¦è®Šå¾—æ›´ç™½äº® (æ°£æ³¡æ„Ÿ)
                            const heightFactor = Math.max(0, (pos[idx+1] + 2.0) * 0.1);
                            col[idx] = heightFactor * 0.5; 
                            col[idx+1] = 0.6 + heightFactor * 0.4; 
                            col[idx+2] = 0.9 + heightFactor * 0.1;
                            
                        } else if (isWisdomGesture) {
                            // --- æ–°å¢ï¼šæ™ºæ…§åˆåæ‰‹å‹¢è§¸ç™¼çœŸç†èºæ—‹ ---
                            // æ°´æµåŒ–ç‚ºé‡‘è‰²é›™èºæ—‹ä¸Šå‡
                            
                            const helixRadius = 1.5;
                            const helixSpeed = 2.0;
                            const riseSpeed = 0.05;
                            const strand = (idx % 2 === 0) ? 1 : -1; // é›™è‚¡
                            
                            const angle = time * helixSpeed + pos[idx+1] * 0.5;
                            
                            // ç›®æ¨™ä½ç½®è¨ˆç®—
                            const tx = Math.cos(angle + strand * Math.PI) * helixRadius;
                            const tz = Math.sin(angle + strand * Math.PI) * helixRadius;
                            
                            // å‘ä¸Šæµå‹•
                            pos[idx+1] += riseSpeed;
                            if (pos[idx+1] > 6.0) pos[idx+1] = -2.0; // å¾ªç’°
                            
                            // æ°´å¹³ä½ç½®é€¼è¿‘
                            pos[idx] += (tx - pos[idx]) * 0.1;
                            pos[idx+2] += (tz - pos[idx+2]) * 0.1;
                            
                            // é‡‘è‰²
                            col[idx] = 1.0; col[idx+1] = 0.8; col[idx+2] = 0.0;
                            
                        } else {
                            // --- éœæ­¢æ¨¡å¼ (æ»¿æ± æ˜¥æ°´ - ä¿®æ­£è¦†è“‹) ---
                            // æ°´åœ¨åº•åº§é•·æ–¹é«”ç¯„åœå…§æµå‹•
                            
                            // ä¿®æ­£ï¼šä½¿ç”¨ full range
                            const poolW = 10.0;
                            const poolD = 6.0;
                            
                            // é‡æ–°æ˜ å°„éš¨æ©Ÿä½ç½®
                            // (randomOffsets - 0.5) * 10
                            // ä¿®æ­£ï¼šä½¿ç”¨ GenerateShape è£¡è¨­å®šå¥½çš„ targetPositions
                            // ç¢ºä¿æ°´é¢è¦†è“‹èˆ‡åˆå§‹ç”Ÿæˆä¸€è‡´
                            const tx = targetPositions[idx]; 
                            // ä½†æˆ‘å€‘åªå–å…¶ x, zï¼Œy å¼·åˆ¶åœ¨æ°´é¢ -2.0
                            
                            const wave = Math.sin(time * 2.0 + tx * 0.5) * 0.1 + Math.cos(time * 1.5 + targetPositions[idx+2] * 0.5) * 0.1;
                            const ty = -2.0 + wave; 
                            const tz = targetPositions[idx+2];
                            
                            // å¿«é€Ÿç·©å‹•ä»¥å¡«æ»¿
                            pos[idx] += (tx - pos[idx]) * 0.1;
                            pos[idx+1] += (ty - pos[idx+1]) * 0.1;
                            pos[idx+2] += (tz - pos[idx+2]) * 0.1;
                            
                            // é¡è‰²ï¼šå¹³éœæ·±è—
                            col[idx] = 0.0; col[idx+1] = 0.3; col[idx+2] = 0.5; 
                        }
                    }
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>